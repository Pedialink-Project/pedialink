name: Sync main into role branches

on:
  push:
    branches:
      - main

permissions:
  contents: write           # needed to read repo contents and create branches/commits if required
  pull-requests: write      # needed to create/update and merge PRs

jobs:
  sync-role-branches:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        portal-branch:
          - TASK-81-phm-portal
          - TASK-82-parent-portal
          - TASK-83-doctor-portal
          - TASK-90-admin-portal

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Create or update PR (main → role branch) and try auto-merge
        uses: actions/github-script@v7
        env:
          TARGET_BRANCH: ${{ matrix.portal-branch }}
        with:
          github-token: ${{ secrets.SYNC_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const base = process.env.TARGET_BRANCH;
            const head = 'main';
            const title = `Sync main → ${base}`;
            const body = `Automated sync: keeping ${base} up-to-date with \`main\`.\n\nIf this PR has conflicts or failing checks, please resolve them manually in the ${base} branch.`;

            // --- helper sleep ---
            const sleep = ms => new Promise(res => setTimeout(res, ms));

            // 1) find or create PR
            let prList = await github.rest.pulls.list({
              owner, repo, state: 'open', head: `${owner}:${head}`, base: base, per_page: 100
            });

            let pr;
            if (prList.data && prList.data.length > 0) {
              pr = prList.data[0];
              await github.rest.pulls.update({ owner, repo, pull_number: pr.number, title, body });
              console.log(`Found existing PR #${pr.number} (main → ${base}).`);
            } else {
              try {
                const createResp = await github.rest.pulls.create({ owner, repo, title, head, base, body });
                pr = createResp.data;
                console.log(`Created PR #${pr.number} (main → ${base}).`);
              } catch (err) {
                console.log(`Failed to create PR for base=${base}: ${err.message}`);
                throw err;
              }
            }

            // --- 2) Wait for GitHub to compute mergeability (exponential backoff) ---
            let tries = 0;
            let delay = 3000; // 3s initial
            const maxMergeableTries = 8; // ~3 + 6 + 12 + 24 + 48 ... up to ~4+ minutes worst-case

            while ((pr.mergeable === null || pr.mergeable_state === 'unknown') && tries < maxMergeableTries) {
              console.log(`mergeable not ready yet (try ${tries+1}/${maxMergeableTries}). waiting ${delay}ms...`);
              await sleep(delay);
              const refreshed = await github.rest.pulls.get({ owner, repo, pull_number: pr.number });
              pr = refreshed.data;
              tries++;
              delay = Math.min(delay * 2, 60000); // cap delay to 60s
            }

            console.log(`After polling: pr.mergeable=${pr.mergeable} pr.mergeable_state=${pr.mergeable_state}`);

            // If it's explicitly not mergeable or in a "dirty" state (conflicts), bail out for manual resolution
            const badStates = ['dirty', 'unknown']; // 'dirty' indicates merge conflicts
            if (pr.mergeable === false || badStates.includes(pr.mergeable_state)) {
              console.log(`PR #${pr.number} is not auto-mergeable (state=${pr.mergeable_state}). Leaving it open for manual resolution.`);
              return;
            }

            // --- 3) Wait for status checks / check-runs to complete and be successful ---
            // We'll wait up to ~5 minutes by default (configurable by attempts/delay)
            const maxCheckAttempts = 20;
            let checkAttempt = 0;
            const checkDelayMs = 15000; // 15s between checks

            const acceptableConclusions = new Set(['success', 'neutral', 'skipped']); // adjust if you want stricter (success only)

            while (checkAttempt < maxCheckAttempts) {
              // Combined status (classic status API)
              const combinedStatus = await github.rest.repos.getCombinedStatusForRef({
                owner, repo, ref: pr.head.sha
              });

              // Check-run API (modern checks)
              const checks = await github.rest.checks.listForRef({
                owner, repo, ref: pr.head.sha
              });

              const anyCheckRunning = checks.data.check_runs.some(cr => cr.status !== 'completed');
              const anyCheckFailed = checks.data.check_runs.some(cr => (cr.status === 'completed' && !acceptableConclusions.has(cr.conclusion)));

              console.log(`Status state = ${combinedStatus.data.state}, check_runs total=${checks.data.total_count}, running=${anyCheckRunning}, failed=${anyCheckFailed}`);

              // If any check is still running -> wait
              if (anyCheckRunning || combinedStatus.data.state === 'pending') {
                console.log(`CI still running for commit ${pr.head.sha}. Waiting ${checkDelayMs}ms (attempt ${checkAttempt+1}/${maxCheckAttempts})...`);
                await sleep(checkDelayMs);
                checkAttempt++;
                continue;
              }

              // All checks completed. If combined status is success OR all check-run conclusions are acceptable -> proceed
              if (combinedStatus.data.state === 'success' || (!anyCheckFailed && checks.data.total_count > 0)) {
                console.log('All checks complete and passing (or acceptable). Proceeding to merge attempt.');
                break;
              }

              // If combined status is 'failure' or some checks failed -> do not auto-merge
              console.log(`Checks indicate failure (combined state=${combinedStatus.data.state}). Not auto-merging PR #${pr.number}.`);
              return;
            }

            if (checkAttempt >= maxCheckAttempts) {
              console.log('Timed out waiting for CI/check runs to finish. Leaving PR open for manual handling.');
              return;
            }

            // --- 4) Try to merge and handle errors gracefully ---
            try {
              const mergeResp = await github.rest.pulls.merge({
                owner, repo, pull_number: pr.number, merge_method: 'merge'
              });
              if (mergeResp.data && mergeResp.data.merged) {
                console.log(`Successfully auto-merged PR #${pr.number} into ${base}.`);
              } else {
                console.log(`Merge attempted but not merged: ${JSON.stringify(mergeResp.data)}`);
              }
            } catch (err) {
              // Common reasons: branch protection requires reviews or commit status checks, or race conditions
              console.log(`Auto-merge failed for PR #${pr.number}: ${err.message}`);
              // don't throw — leave PR open for humans
            }
